# Теория по Go

- Здесь будет собрана теория в текстовом виде ради увеличения скорости ее запоминания и возможность подглядеть при необходимости

## Самая база

1. Go является языком со строгой типизацией. Есть вариант объявлять и инициализировать переменные в обычном формате, однако при этом есть возможность пользоваться утиной типизацией. Также наименования в Go записываются в **camelCase**: 

    ```go
    var characterName string = "Darth Vader"  // строгая типизация
    characterName := "Darth Vader" // утиная типизация
    ```

    При этом нельзя менять тип хранимых данных в переменной после ее объявления. Условно, если в переменной хранится интовое значение, то в переменную в последствии можно записывать только инты. А вот другие типы данных не получится


2. Go является компилируемым языком (код, написанный на Go сразу читается как машинный код (бинарка) без предварительного перевода, как в Python). Например, прогон цикла for от 1 до 100млн. с суммированием каждого значения займет на питоне 6 секунд, в то время как гошка справится за 50 мс, что в 120 раз быстрее. Также сама компиляция кода на Go занимает очень мало времени. А еще в Go есть нормальный параллелизм

--- 

## Типы и структуры данных

- В принципе, здесь тоже все стандартно за исключением `float` - при использовании плавающей точки требуется указывать кол-во бит на переменную (32 или 64), хотя тот же `int` можно определить как простой int без указывания его размерности, имхо она выберется автоматом

- Для каста совместимых типов данных (int во float, например), требуется просто обернуть переменную для каста в требуемых тип данных
    ```go
    var intNum32 int32 = 23
    var result float64 = float64(intNUm32)
    ```

- При этом есть возможность создавать константы - переменные, которые нельзя изменить. При их объявлении требуется указать `const` вместо `var`. При попытке изменить константу интерпретатор выдаст ошибку

- Для создания многострочной строки (тройные кавычки в питоне) стоит использовать '`':
    ```go
    var text string = `oh
    my
    god`
    ```

- Также в Go есть интересный тип данны - `rune`(руны). Это символы из ASCII кодировки, которые имеют слишком большие индексы, из-за чего кодируются несколькими байтами. Работа с ними может несколько ломать метод **len()**, поскольку он считает именно что кол-во байт, которые труебются на хранение переменной. Для перевода рун в чары используется метод `utf8.RuneCountInString(rune)` из пакета `unicode/utf8`

- Еще существует такое понятие, как 'значение по умолчанию'. Если просто объявить переменную и не инициализировать ее, переменная получит значение по умолчанию для ее типа данных. Для всех видов `int`, `float`, `rune` это значение равно 0, для `string` - '', для `bool` - False

---

## Циклы

- Что интересно, в Go, фактически, есть только цикл `for`, который имеет весьма широкую настройку. Общепринятый паттер `for` выглядит следующим образом: 
    ```go
    for [инициализация счетчика]; [условие]; [изменение счетчика]{
        // do something
    }
    ```

    При этом есть возможность заранее проиницилазировать счетчик, а внутрь цикла впихнуть его изменение, что приводит к виду
    ```go
    var ind int = 0
    for ind < 10 {
        ind++
    }

    for ; ind < 10 ; {
        ind++
    }
    ```

- Если речь идет про итерацию в коллекциях (строки, списки), используется несколько отличающийся и одновременно похожий вариант на питон: 
    ```go
    for ind, value := range collection {
        // do something
    }
    ```

    Другими словами, в базовом варианте итерация по коллекции идет ровно так, как с использованием **enumerate()** в питоне. Если же нам нужны только индексы или только значения, вместо переменной в декларировании стоит указать андер, что логично

- Операторы `break` и `continue` реализованы ровно так, как они реализованы в питоне. Просто **break** в строке, и все. Но при этом оператор `break` можно применять и для выхода из внешних циклов. В питоне я такого не встречал и писал костыли с фалагми, а здесь такое есть: 

    ```go
    package main
    import "fmt"
    
    func main() {
        
    // метка для перехода к внешнему циклу
    OuterLoop:
        for i := 1; i <= 3; i++ {
            for j := 1; j <= 3; j++ {
    
                fmt.Printf("i = %d, j = %d\n", i, j)
    
                if i == 2 && j == 2 {
    
                    fmt.Println("Выход из внешнего цикла...")
    
                    break OuterLoop // выходим из внешнего цикла
                }
            }
        }
    
        fmt.Println("Цикл завершен...")
    }
    ```

    Интересно, является ли этичным использование меток, потому что подобная структура напоминает мне ванильный `goto`, что не круто. Если верить гпт, решение с метками для цикла НЕ является антипаттерном, если ее применение действительно оправдано. Единственный вариант оправдания использование подобных меток, которое не противоречит другим правилам этики разработки - сделать код понятнее и проще. Т.е. если нет возможности для рефакторинга, но сделать надо - окей, но почти всегда подобный вариант можно обернуть в метод, ввиду чего решение больше сомнительное, чем нет 

---

## Функции

- Функции в Go объявляются следующим образом: 

    ```go
    func имя_функции (список_параметров) (типы_возвращаемых_значений){
        // do something
    }
    ```

    Название функции вместе с типами принимаемых параметров и возращаемх значений называют **сигнатурой функции**. По умолчанию каждая функция в Go должна содержать хотя бы одну функцию - функцию **main**. Функция main не принимает никаких параметров, поэтому ее атрибуты пусты: 

    ```go
    package main
    import "fmt"

    func main() {
        fmt.Println("Hello World!")
    }
    ```

- Если несколько параметров функции имеют один и тот же тип данных, можно указать тип данных только для **последнего** параметра: 

    ```go
    func add(x, y int, a, b, c float32){
        // do something
    }
    ```

    Мне этот вариант кажется неявным, ввиду чего я не буду его использовать. Каждому параметру по типу данных! 

- Также в Go функция может принимать **неопределенное** кол-во параметров одного типа: 

    ```go
    func add(numbers ...int) int {
        var sum int = 0
        for _, val := range numbers {
            sum += val
        }

        return sum
    }
    ```

    Грубо говоря, многоточие `...` является сигналом к подаче неопределенного кол-ва аргументов

- Если указывать имя возвращаемого значения в сигнатуре функции, его не стоит повторно инициализировать внутри, поскольку возвращаемое значение инициализируется как раз в сигнатуре функции. Т.е. выше описанный вариант будет полностью идентичен описанному ниже варианту 

    ```go
    func add(numbers ...int) (sum int) {
        for _, val := range numbers {
            sum += val
        }

        return sum
    }
    ```

    А чтобы вернуть сразу несколько значений, в сигнатуре функции в области для возвращаемых параментров стоит просто перечислить их, или перечислить возвращаемые типы данных

- Из интересных моментов, которые логичны, но которые я раньше не использовал и не видел - функции, например, можно передавать в качестве аргументов других функций. Т.е. иногда встречается логика, в которой функция 1 выполняет внутри себя передаваемые ей функции 2 и 3. Такой вариант кажется мне странным - зачем передавать в аргументах функции другие функции, если есть, по крайней мере в питоне, разнообразные области видимости, прекрасный ООП, но до него я не дошел. Также интересный вариант - написать функцию, которая в зависимости от входных данных будет передавать ссылки на различные функции. Например, при негативных значениях в return идет один метод, при положительных - другой

- В гошке существуют анонимые (lambda) функции: 

    ```go
    sum_func := func(x int, y int) int {return x + y}
    ```

    Данные функции часто зачастую используются в качестве аргументов других функций, а также как результаты работы других функций (происходит объявление лямбда-функции, после return возвращает результат ее работы)

- Еще частичка для заполнения пробелов. `Замыкания` работают весьма интересно. Например: 

    ```go
    func outer() func() {
        var n int = 5
        inner := func() {
            n += 1
            fmt.Prntln(n)
        }
        return inner
    }

    func main() {
        fn := outer()

        fn() // -> 6
        fn() // -> 7
        fn() // -> 8
    }
    ```

    В переменную **fn** записывается метод **inner**, который в своей области видимости 'запомнил' переменную n, которую каждый раз и инкрементирует. Т.е. замыкания в go захватывают сами переменные, а не их значения. Приведенный выше код будет полностью индентичен приведенному ниже (в нем полное объявление функции inner щаменено на lambda-функцию):

    ```go
    func outer() func() {
        var n int = 5
        return () {
            n += 1
            fmt.Println(n)
        }
    }
    ```

---

## Указатели

- В гошке есть и указатели, которые стоит использовать в том случае, когда требуется изменить оригинальное значение переменной, а не создать ее копию, после чего изменить оригинальное значение путем замены его на копию, например. Подобный подход эффективен при работе с большими структурами (массив интов на лярд элементов). Или когда нужна ссылка на **nil**, поскольку обычная переменная не может быть nil'ом, а указатель может

- Синтаксис у указателей весь простой - для создания переменной-указателя перед ее типом значения используется `'*'`, а для получения адреса переменной - `'&'`: 

    ```go
    var int_var int = 42
    var int_pointer *int = &int_var
    ```

    В случае, если только обхявить указатель, но при этом не инициализировать его, он примет значени **nil**

- Существует ключевое слово new, которое позволяет сразу передать указателю адрес объекта, а не инициализировать переменную, чтобы после передать указателю ее адрес:

    ```go
    var int_pointer *int = new(42)
    ```

---

## Терминал

- Если посмотреть на вывод **go help**, можно увидеть не очень малое множество допустимых команд (у каждой еще свои подкоманды), но основные вот: 

    1. `go run`. Компиляция и запуск go-скриптов
    2. `go build`. Компиляция go-скриптов в исполняемый файл без последующего запуска скомпилированного файла
    3. `go install`. Установка пакетов в **$GOBIN**
    4. `go test`. Запуск тестов в указанном пакете. Используеся для модульного тестирования
    5. `go mod`. Управление зависимостями (**init**, **tidy**)
    6. `go fmt`. Автоматическое форматирование кода
    7. `go vet`. Проверка кода на типичные ошибки
    8. `go doc`. Показывает документацию к пакету
    9. `go list`. Выводит список зависимостей в проекте

---

## Корутины

--- 

## Каналы

---

## Дженерики

---

## Стиль

- Стиль в гошке весьма интересный. Например, не стоит повторять в названиях методов наименования пакетов, а также для методов не стоит повторять наименования аргументов, принимаемых методом, в его названии. Честно, не понимаю, почему - при использовании имен аргументов в имени метода становится лучше понятно, с чем мы взаимодействуем, но здесь это харам. Т.е. является харамом что-то вроде: 

    ```go
    package yamlconfig

    func ParseYAMLConfig(input string) (*Config, error)

    func (c *Config) WriteConfigTo(w io.Writer) (int64, error)

    func OverrideFirstWithSecond(dest, source *Config) error
    ```

    Но при этом в случае наличия метода со схожим названием при инициализации нового метода допускается указание дополнительной информации, которую лучше не включать в исходное название в соответствии с описанным выше: 

    ```go
    func (c *Config) WriteTextTo(w io.Writer) (int64, error)
    func (c *Config) WriteBinaryTo(w io.Writer) (int64, error)
    ```

    - Также не стоит добавлять фразы, описывающее получение информации. `Get`, например. Для метода который возвращает, допустим, наименование работы, лучше использовать название `JobName`, а не **Get**JobName
    - А для методов, которые что-то делают (записывают, например), будет правильным использовать глаголы в их названии - `WriteDetail`
    - Если разница метода только в байтах принимаемого значения (int32, int64), стоит указывать это в названии (ParseInt32 - ParseInt64)

# Советы по написанию поддерживаемых программ

## Идентификаторы

- Идентификаторы - синонимы имен. В принципе, если не смотреть на 'правильный стиль' с точки зрения самого кода, а смотреть на 'правильный стиль' с точки зрения человека, который будет его читать и поддерживать, здесь очень много аналогий с тем же питоном. Т.е. в ход идет этика разработчика, а не этика языка
- Имена переменным лучше давать исходя из их ясности, а не краткости, о которой я писал выше. Хорошее имя лаконично, оно является спасательным (имя метода должно описывать применение переменной, а не ее содержимое. Хорошее имя описывает результат функции или поведение метода, а не его реализацию. назначение пакета, а не его содержимое). Хорошее имя предсказуемо. Также важно упомянуть, что Go вляется языков со строгой типизацией, ввиду чего просто не позволит передать, например в параметр метода с типом **map** объект скалярного типа, ввиду чего суффиксы с наименованием обрабатываемого типа данных просто излишни:
    ```go
    var usersMap map[string]*User  // суффикс 'Map' излишен
    ```
- Интересная практика, о которой я прочитал - давать переменным/методам тем большее имя, чем дальше от момента инициализации переменной/метода она/он будет использован(-а). Т.е. если метод используется единожд сразу после инициализации, нет смысла делать его имя длинным, а если метод используется на протяжении длинного участка кода, стоит обозвать его более длинным именем и привнести больше контекста в это имя:

    ```go
    type Person struct {
        Name string
        Age  int
    }

    // AverageAge returns the average age of people.
    func AverageAge(people []Person) int {
        if len(people) == 0 {
            return 0
        }

        var count, sum int
        for _, p := range people {
            sum += p.Age
            count += 1
        }

        return sum / count
    }
    ```

    Грубо говоря, длина имени должна показывать важность переменной. Это логично, но раньше этот принцип я использовал на подсознательном уровне

- В Go принято соглашение, что интересно, о максимальном сокращении имен объектов. Зачастую, если рассматривать аргументы методов, например, аргумент является сокращением от его типа (структура Person -> аргумент p)

- Также рекомендуется использовать единый стиль деклораций (объявление и инициализация). Мне больше всего понравился вариант `var x int = 5`. Т.е. `var x int` преобладает над `var x = 0`. Остановлюсь на нем. Также, если требуется задать нулевое значение определенного типа, переменная просто объявляется, без инициализации (тоже использовать). Если 2 переменные близко связаны между собой, стоит проводить их декларацию в одной строке: 

    ```go
    var min, max := 0, 1000
    ```

- Если есть разногласия по стилю, их стоит выносить на обсуждения только в том случае, если код не проходит через `go fmt`

---

## Комментарии

- Важно понимать, что комментарий должен делать одну и только одну вещь из 3-х приведенных: 
    1. Объяснить, что делает код
    2. Объяснить, как код что-то делает
    3. Объяснить, зачем код что-то делает

- Комментарии в переменных и константах должны описывать их содержимое, а не предназначение: 
    ```go
    // sizeCalculationDisabled указывает, безопасно ли
    // рассчитать ширину и выравнивание типов. См. dowidth.
    var sizeCalculationDisabled bool
    ```

- Иногда лучшее имя для переменной скрывается в комментарии. В примере приведено имя `register` - понятно, что регистр, но регистр чего? если добавить уточнение, что он связан с sql, например `sqlDrivers`, то станет лучше: 
    ```go
    // реестр драйверов SQL
    var registry = make(map[string]*sql.Driver)
    ```

- При разработке своих пакетов лучше всего комментировать все, что не является кратким и явным одновременно. При этом любая функция должна быть прокомментирована вне зависимости от ее краткости и сложности. Однако есть исключение - не стоит документировать методы, реализующие интерфейс: 
    ```go
    // Read реализует интерфейс io.Reader
    func (r *FileReader) Read(buf []byte) (int, error)
    ```

    Приведенный комментарий приосит больше ущерба, чем пользы - в нем нет никакой информации кроме той, что и так ясна из строки кода

- Если стало понятно, что код перед глазами попахивает, лучше всего его переписать, чем насыщать его комментариями. Если столкнусь с подобным комментарием, лучше завести тикет с напоминанием о рефакторинге. Также буде правильным решением в тикете указать ник человека, который либо заметил проблему, либо к которому лучше обратиться за решением проблемы

---

## Структура пакета

- Важная особенность Go по сравнению с другими языками (java, c++) - в нем нет столь большого модификатора доступов. В Go всего 2 модификатора доступа: общедоступный и правтный идентификаторы, что обозначается первой буквой идентификатора (заглавная/строчня). Если модификатор общедоступный, его имя начинается с большой буквы, и на него может ссылаться любой другой пакет в Go

- Лучше предпочесть меньшее кол-во пакетов большего размера, чем наоборот. Но при этом стоит помнить, что каждый пакет должен выполнять строго одну функцию (парсинг .xml или журналирование), иначе велик шанс повторить судьбу пакета common. Также в каждом пакете, кроме `cmd/` и `internal/` должен находиться исходный код

- Рекомендации при создании пакетов: 
    1. Начинать каждый пакет с одного .go файла. Лучше всего присвоить ему то же имя, что и у каталога (для каталога **https** первым файлом лучше всего сделать **https.go**)
    2. При росте пакета можно разделить различные функции на несколько файлов. Например, файл **messages.go** будет содержать типы Request и REsponse, файл client.go - тип Client, файл server.go - тип сервера
    3. Если у файлов оказались похожие декларации импорта, стоит подумать об их объединении. Как вариант, можно проанализировать наборы импорта и переместить их
    4. Разные файлы должны отвечать за разные области пакета. Не стоит разделять логику по работе с одним направлением на несколько файлов

- Касательно тестов - стоит предпочитать внутренние тесты внешним. Пример 'внутреннего теста' в разговорной речи - под файл **http.go** можно написать файл **http_test.go** и использовать декларацию пакета **http**. Данное действие скомпилирует код **http_test.go**, как будто он часть пакета **http**. Опять же, подобный тест называется **внутренним** в разговорной речи

- Инструмент **go** также поддерживает специальное объявление пакета, заканчивающее суффиксом `test`, что позволяет тестовым файлам жить в одном пакете с кодом, но когда такие тесты компилируются, они не является часть кода пакета, в котором находятся, а живут в своем собственном пакете, что позволяет писать тесты так, словно другой пакет вызывает тестовый код. Подобные тесты называются **внешними** 

- Оптимальнее всего использовать внутренние тесты, поскольку они позволят целенаправленно тестировать каждый метод/функцию, избегая лишней бюррократии внешнего тестирования. НО обязательно нужно поместить во внешний тестовый файл примеры тестовых функций (`Example`), что гарантирует, что при просмотреть в **godoc** примеры получат соответствующий префикс пакета и могут быть легко скомпилированы

---

## Структура проекта

---

## Структура API

---

## Обработка ошибок

---

## Параллелизм

---

остановился на пункте 5.1.3