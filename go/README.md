# Теория по Go

- Здесь будет собрана теория в текстовом виде ради увеличения скорости ее запоминания и возможность подглядеть при необходимости

## Самая база

1. Go является языком со строгой типизацией. Есть вариант объявлять и инициализировать переменные в обычном формате, однако при этом есть возможность пользоваться утиной типизацией. Также наименования в Go записываются в **camelCase**: 

    ```go
    var characterName string = "Darth Vader"  // строгая типизация
    characterName := "Darth Vader" // утиная типизация
    ```

    При этом нельзя менять тип хранимых данных в переменной после ее объявления. Условно, если в переменной хранится интовое значение, то в переменную в последствии можно записывать только инты. А вот другие типы данных не получится


2. Go является компилируемым языком (код, написанный на Go сразу читается как машинный код (бинарка) без предварительного перевода, как в Python). Например, прогон цикла for от 1 до 100млн. с суммированием каждого значения займет на питоне 6 секунд, в то время как гошка справится за 50 мс, что в 120 раз быстрее. Также сама компиляция кода на Go занимает очень мало времени. А еще в Go есть нормальный параллелизм

--- 

## Типы и структуры данных

- В принципе, здесь тоже все стандартно за исключением `float` - при использовании плавающей точки требуется указывать кол-во бит на переменную (32 или 64), хотя тот же `int` можно определить как простой int без указывания его размерности, имхо она выберется автоматом

- Для каста совместимых типов данных (int во float, например), требуется просто обернуть переменную для каста в требуемых тип данных
    ```go
    var intNum32 int32 = 23
    var result float64 = float64(intNum32)
    ```

- При этом есть возможность создавать константы - переменные, которые нельзя изменить. При их объявлении требуется указать `const` вместо `var`. При попытке изменить константу интерпретатор выдаст ошибку

- Для создания многострочной строки (тройные кавычки в питоне) стоит использовать '`':
    ```go
    var text string = `oh
    my
    god`
    ```

- Также в Go есть интересный тип данны - `rune`(руны). Это символы из ASCII кодировки, которые имеют слишком большие индексы, из-за чего кодируются несколькими байтами. Работа с ними может несколько ломать метод **len()**, поскольку он считает именно что кол-во байт, которые труебются на хранение переменной. Для перевода рун в чары используется метод `utf8.RuneCountInString(rune)` из пакета `unicode/utf8`

- Еще существует такое понятие, как 'значение по умолчанию'. Если просто объявить переменную и не инициализировать ее, переменная получит значение по умолчанию для ее типа данных. Для всех видов `int`, `float`, `rune` это значение равно 0, для `string` - '', для `bool` - False

---

## Строки и руны

- Строки в гошке сильно отличаются от строк в других языков: в других ЯП строка нередко определяется как массив символов, но в Go строка — это срез байтов. Для преобразования набора байтов (среза байтов) в строку применяется встроенная функция string():

    ```go
    binary_str := [] byte{208, 159, 209, 128, 208, 184, 208, 178, 208, 181, 209, 130, 32, 208, 188, 208, 184, 209, 128 }
    str := string(binary_str)
 
    fmt.Println(str)    // Привет мир
    ```

    В гошке нельзя изменить строку после ее создания, ввиду чего строка, грубо говоря, - срез байтов с модом **ro**. Но при этом, если требуется поменять какой-либо символ в строке, можно кастануть ее в список рун, после чего изменить требующий изменения элемент, а затем вернуть руны в строку

- rune представляет встроенный тип данных в языке Go. В реальности это псевдоним для int32, поскольку Unicode UTF-8 кодирует символ в уникальное число или кодовую точку. Руна и представляет эти кодовые точки Unicode в Go. Она не связана с количеством байтов, которые занимает символ

- Все методы взаимодейсвтия со строками в гошке идентичны методам из питона за тем исключением, что нейминг идет не в snake-case, а в capitalize

---

## Производные типы данных

- Оператор type позволяет определять для некоторого типа псевдоним. Псевдоним не представляет новый тип, а лишь определяет новое название для уже существующего типа. Например:

    ```go
    type mile uint
    ```

    В данном случае для типа uint определяется псевдоним mile, который основывается на типе uint. По сути mile представляет тип uint и работа с ним будет производиться также, как и с типом uint. Однако в то же время фактически это новый тип. Подобные преобразования часто используются, когда нужно конкретизировать тип переменной. Например, если требуется вычислить расстояние до противника, с меньшей вероятностью буду переданы неверные данные, если заранее указать, что для вычисления расстояния нужны метры/километры и т.д. 
    
    Грубо говоря, основной смысл алиаса для типа данных заключается в насыщении смыслом переменных. А также алиасы используются для сокращения названий слишком длинных типов данных: 

    ```go
    type BinaryOp func(int, int) int  // теперь при создании функций с типом func(int, int) int не надо использовать столь громоздкий тип. Можно ограничиться лаконичным BinaryOp
    ```

- Структуры в гошке идентичны структурам из питона: 

    ```go
    type struct_name struct{
        field1 field_type1 
        field2 field_type2
        ...............
        fieldN field_typeN
    }
    ```

    Если типы данных у нескольких полей одинаковы, ничто не мешает инициализировать их в одной строке: field1, field2 field_type. Сама же структура представляет собой новый тип данных

- Допустим, у нас есть структура Person: 

    ```go
    type Person struct {
        name string
        age int
    }
    ```

    Декларировать переменную, являющуюся структурой Person следует следующим образом (мне по душе второй вариант): 

    ```go
    var some_person Person = Person{"Dmitriy", 20}
    var another_person Person = Person{name="Dmitriy", age=20}
    ```

- Обращение к полям структуры происходит следующим образом, что логично: 

    ```go
    fmt.Println(some_person.name, some_person.age)
    ```

- Также не обязательно объявлять для структуры новый тип - можно создать анонимную структуру: 

    ```go
    var AnonimusPerson struct {
        anon_name string
        anon_age int
    }
    ```

    Взаимодействие с анонимной структурой ровно такое же, как и с обычной. При этом есть еще вариант создавать анонимные поля структур: 

    ```go
    var RealyAnonimusPerson struct {
        string
        int
    }
    var rap := RealyAnonimusPerson("who am i?", 42) 
    ```
    При этом если есть 2 и более поля структуры с одинаковым тип данных, при компиляции произойдет ошибка. Нельзя указывать более одного анонимного поля с определенным типом данных

- Гошка позволяет определять поля структур как значения других структур. В этом случае мы имеем дело с вложенными и встроенными структурами:

    1. Вложенные структуры (nested struct) определяются как именованные поля внутри другой структуры, и доступ к их полям осуществляется с использованием имени поля внешней структуры.

    2. Встроенные структуры (embedded struct) определяются без имени поля, что продвигает их поля во внешнюю структуру для прямого доступа. Встроенные структуры предлагают более чистый синтаксис, но могут вызывать конфликты имен.

- Метод представляет функцию, связанную с определенным типом. Методы определяются также как и обычные функции за тем исключением, что в определении метода также необходимо указать получателя или receiver. Получатель - это параметр того типа, к которому прикрепляется метод:

    ```go
    func (parameter_name reciever_name) method_name (method_parametrs) (returned_results_types){
        method_body
    }
    ```

    Допустим, у нас будет определен именованный тип, представляющий срез из строк: `type library []string`. Для вывода всех элементов из среза мы можем определить следующий метод:

    ```go
    func (l library) print(){
 
        for _, val := range l{
            fmt.Println(val)
        }
    }
    ```

---

## Циклы

- Что интересно, в Go, фактически, есть только цикл `for`, который имеет весьма широкую настройку. Общепринятый паттер `for` выглядит следующим образом: 
    ```go
    for [инициализация счетчика]; [условие]; [изменение счетчика]{
        // do something
    }
    ```

    При этом есть возможность заранее проиницилазировать счетчик, а внутрь цикла впихнуть его изменение, что приводит к виду
    ```go
    var ind int = 0
    for ind < 10 {
        ind++
    }

    for ; ind < 10 ; {
        ind++
    }
    ```

- Если речь идет про итерацию в коллекциях (строки, списки), используется несколько отличающийся и одновременно похожий вариант на питон: 
    ```go
    for ind, value := range collection {
        // do something
    }
    ```

    Другими словами, в базовом варианте итерация по коллекции идет ровно так, как с использованием **enumerate()** в питоне. Если же нам нужны только индексы или только значения, вместо переменной в декларировании стоит указать андер, что логично

- Операторы `break` и `continue` реализованы ровно так, как они реализованы в питоне. Просто **break** в строке, и все. Но при этом оператор `break` можно применять и для выхода из внешних циклов. В питоне я такого не встречал и писал костыли с фалагми, а здесь такое есть: 

    ```go
    package main
    import "fmt"
    
    func main() {
        
    // метка для перехода к внешнему циклу
    OuterLoop:
        for i := 1; i <= 3; i++ {
            for j := 1; j <= 3; j++ {
    
                fmt.Printf("i = %d, j = %d\n", i, j)
    
                if i == 2 && j == 2 {
    
                    fmt.Println("Выход из внешнего цикла...")
    
                    break OuterLoop // выходим из внешнего цикла
                }
            }
        }
    
        fmt.Println("Цикл завершен...")
    }
    ```

    Интересно, является ли этичным использование меток, потому что подобная структура напоминает мне ванильный `goto`, что не круто. Если верить гпт, решение с метками для цикла НЕ является антипаттерном, если ее применение действительно оправдано. Единственный вариант оправдания использование подобных меток, которое не противоречит другим правилам этики разработки - сделать код понятнее и проще. Т.е. если нет возможности для рефакторинга, но сделать надо - окей, но почти всегда подобный вариант можно обернуть в метод, ввиду чего решение больше сомнительное, чем нет 

---

## Функции

- Функции в Go объявляются следующим образом: 

    ```go
    func имя_функции (список_параметров) (типы_возвращаемых_значений){
        // do something
    }
    ```

    Название функции вместе с типами принимаемых параметров и возращаемх значений называют **сигнатурой функции**. По умолчанию каждая функция в Go должна содержать хотя бы одну функцию - функцию **main**. Функция main не принимает никаких параметров, поэтому ее атрибуты пусты: 

    ```go
    package main
    import "fmt"

    func main() {
        fmt.Println("Hello World!")
    }
    ```

- Если несколько параметров функции имеют один и тот же тип данных, можно указать тип данных только для **последнего** параметра: 

    ```go
    func add(x, y int, a, b, c float32){
        // do something
    }
    ```

    Мне этот вариант кажется неявным, ввиду чего я не буду его использовать. Каждому параметру по типу данных! 

- Также в Go функция может принимать **неопределенное** кол-во параметров одного типа: 

    ```go
    func add(numbers ...int) int {
        var sum int = 0
        for _, val := range numbers {
            sum += val
        }

        return sum
    }
    ```

    Грубо говоря, многоточие `...` является сигналом к подаче неопределенного кол-ва аргументов

- Если указывать имя возвращаемого значения в сигнатуре функции, его не стоит повторно инициализировать внутри, поскольку возвращаемое значение инициализируется как раз в сигнатуре функции. Т.е. выше описанный вариант будет полностью идентичен описанному ниже варианту 

    ```go
    func add(numbers ...int) (sum int) {
        for _, val := range numbers {
            sum += val
        }

        return sum
    }
    ```

    А чтобы вернуть сразу несколько значений, в сигнатуре функции в области для возвращаемых параментров стоит просто перечислить их, или перечислить возвращаемые типы данных

- Из интересных моментов, которые логичны, но которые я раньше не использовал и не видел - функции, например, можно передавать в качестве аргументов других функций. Т.е. иногда встречается логика, в которой функция 1 выполняет внутри себя передаваемые ей функции 2 и 3. Такой вариант кажется мне странным - зачем передавать в аргументах функции другие функции, если есть, по крайней мере в питоне, разнообразные области видимости, прекрасный ООП, но до него я не дошел. Также интересный вариант - написать функцию, которая в зависимости от входных данных будет передавать ссылки на различные функции. Например, при негативных значениях в return идет один метод, при положительных - другой

- В гошке существуют анонимые (lambda) функции: 

    ```go
    sum_func := func(x int, y int) int {return x + y}
    ```

    Данные функции часто зачастую используются в качестве аргументов других функций, а также как результаты работы других функций (происходит объявление лямбда-функции, после return возвращает результат ее работы)

- Еще частичка для заполнения пробелов. `Замыкания` работают весьма интересно. Например: 

    ```go
    func outer() func() {
        var n int = 5
        inner := func() {
            n += 1
            fmt.Prntln(n)
        }
        return inner
    }

    func main() {
        fn := outer()

        fn() // -> 6
        fn() // -> 7
        fn() // -> 8
    }
    ```

    В переменную **fn** записывается метод **inner**, который в своей области видимости 'запомнил' переменную n, которую каждый раз и инкрементирует. Т.е. замыкания в go захватывают сами переменные, а не их значения. Приведенный выше код будет полностью индентичен приведенному ниже (в нем полное объявление функции inner щаменено на lambda-функцию):

    ```go
    func outer() func() {
        var n int = 5
        return () {
            n += 1
            fmt.Println(n)
        }
    }
    ```

---

## Указатели

- В гошке есть и указатели, которые стоит использовать в том случае, когда требуется изменить оригинальное значение переменной, а не создать ее копию, после чего изменить оригинальное значение путем замены его на копию, например. Подобный подход эффективен при работе с большими структурами (массив интов на лярд элементов). Или когда нужна ссылка на **nil**, поскольку обычная переменная не может быть nil'ом, а указатель может

- Синтаксис у указателей весь простой - для создания переменной-указателя перед ее типом значения используется `'*'`, а для получения адреса переменной - `'&'`: 

    ```go
    var int_var int = 42
    var int_pointer *int = &int_var
    ```

    В случае, если только обхявить указатель, но при этом не инициализировать его, он примет значени **nil**

- Существует функция new (функция выделяет пространство памяти в соответствии с размером объекта и возвращает указатель на него), которая позволяет сразу передать указателю адрес объекта, а не инициализировать переменную, чтобы после передать указателю ее адрес:

    ```go
    var int_pointer *int = new(42)
    ```

---

## Пакеты и модули

- Весь код в гошке организуется в `пакеты`. Пакет представляют удобную организацию разделения кода на отдельные части или модули. Физически пакет — это просто каталог/папка, которая содержит несколько файлов с исходным кодом. Для определения пакета применяется ключевое слово package, после которого указывает имя пакета

- Есть два типа пакетов: исполняемые (`executable`) и библиотеки (`reusable`). Для создания исполняемых файлов пакет должен иметь имя **main**. Все остальные пакеты не являются исполняемыми. При этом пакет "main" должен содержать функцию main, которая является входной точкой в приложение

- Если уже есть готовые пакеты с нужной нам функциональностью, которую мы хотим использовать, то для их использования мы можем их импортировать в программу с помощью оператора import, после которого указывается имя импортируемого пакета:
    
    ```go
    import "package_name"
    import (
        "package_name1"
        "package_name2"
    )
    ```

- Чтобы просто импортировать все методы пакет и использовать их без указания имени пакета, требуется в импорте перед именем поставить '.'. Т.е. `import . package_name` гошки является аналогом `from package_name import *` из питона

- Интересный момент при работе с пакетами - если пакет не используется, компилятор выдаст ошибку. Ввиду чего если очень надо импортировать пакет, что пока не используется, перед его импортом ставится андер: 

    ```go
    import _ package_name
    ```

- Когда мы используем какой-то пакет, то при запуске/компиляции проекта Go должен его найти. По умолчанию Go ищет пакеты по следующим путям в том порядке, в котором они перечислены ниже :

    1. Текущая папка (или относительный путь): при импорте пакета с помощью относительного пути Go сначала будет искать его в текущем каталоге проекта, где находится компилируемый файл. Это касается только пакетов, расположенных внутри текущего проекта (модуля), а не сторонних библиотек.

    2. Путь **GOROOT/src**: здесь Go ищет пакеты, которые являются частью стандартной библиотеки Go, например, fmt, net/http, os и т.д. Обычно переменная $GOROOT настраивается автоматически при установке Go, и менять это значение вручную не требуется
    
    3. Папка vendor: если внутри проекта существует данная папка, то Go ищет все остальные пакеты там. Эта папка создаётся командой **go mod vendor** и используется для хранения каких-то сторонних пакетов, например, других разработчиков. Применение этой папки позволяет гарантировать, что ваш проект использует те же версии зависимостей, которые были сохранены при его создании, независимо от глобальных переменных

    4. Локальный кеш модулей: если папка **vendor** отсутствует, Go ищет пакеты в кеше модулей, который расположен по пути, задаваемой переменной **$GOMODCACHE** (это же путь $GOPATH/pkg/mod). По умолчанию GOPATH устанавливается на подкаталог go в домашнем каталоге пользователя ($HOME/go в Unix-подобных системах). Опять же мы можем посмотреть значения этих переменных с помощью команды go env

    5. Удалённые репозитории: если пакета нет в кеше, Go скачивает его на основе информации из файла конфигурации модуля go.mod, который создается для текущего проекта

- Модуль в языке Go представляет коллекцию пакетов, который имеет встроенное версионирование и который можно опубликовать для использования в других проектах. Применение модулей в Go имеет ряд преимуществ:

    1. Изоляция зависимостей: Каждый модуль управляет своими зависимостями независимо, что позволяет избежать конфликтов версий между разными проектами на одном компьютере.

    2. Воспроизводимые сборки: Файлы go.mod (файл конфигурации модуля) и go.sum (содержит криптографические контрольные суммы для проверки целостности зависимостей), которые входят в состав модуля, гарантируют, что любой, кто клонирует ваш репозиторий, сможет собрать проект с теми же версиями зависимостей, что и у вас.

    3. Упрощенное управление версиями: Модули позволяют легко указывать минимальные требуемые версии зависимостей, а также использовать псевдонимы для различных версий или даже заменять модули локальными версиями для разработки.

    4. Децентрализованная разработка: Go может загружать зависимости из различных источников, включая системы контроля версий, таких как GitHub.

- Файлы `go.mod` и `go.sum`:

    1. go.mod: Этот файл объявляет путь к модулю, версию Go, используемую в проекте, и список всех зависимостей с их минимальными требуемыми версиями.

    2. go.sum: Содержит криптографические хеши содержимого всех зависимостей. Это обеспечивает безопасность и воспроизводимость, гарантируя, что загруженные модули не были подделаны.

- Одним из механизмов управления зависимостями в языке Go является использование папки vendor. Применение этой папки позволяет создавать полностью самодостаточные проекты, изолированные от изменений во внешних репозиториях. Папка vendor представляет каталог в корневой папке проекта, в котором хранятся точные копии исходного кода всех зависимостей

---

## Интерфейсы

- Интерфейсы представляют абстракцию поведения других типов. Интерфейсы позволяют определять функции, которые не привязаны к конкретной реализации. То есть интерфейсы определяют некоторый функционал, но не реализуют его. Для определения интерфейса применяется ключевое слово interface: 

    ```go
    type interface_name interface{
        functions_declorations
    }

    type vehicle interface{
        move()
    }
    ```

    Данный интерфейс называется vehicle. Допустим, данный интерфейс представляет некоторое транспортное средство. Он определяет функцию move(), которая не принимает никаких параметров и ничего не возвращает

- Важно понимать, что интерфейсы - это абстракции, а не конкретные типы, будь то int, string или структуры. К примеры, нельзя напрямую создать объект интерфейса: 

    ```go
    var v vehicle = vehicle{}  
    ```

    Интерфейс представляет своего рода контракт, которому должен соответствовать тип данных. Чтобы тип данных соответствовал интерфейсу, данный тип должен реализовать в виде методов все функции этого интерфейса

- Интерфейс, который не содержит ни одного метода, называется пустым интерфейсом. Поскольку каждый тип реализует ноль методов, пустой интерфейс может содержать любое значение. В программировании часто встречаются случаи, когда нет уверенности в типе значения. Для обработки таких случаев используются пустые интерфейсы. Функция print является лучшим примером пустых интерфейсов, которые используются для печати любого значения. Например:

    ```go
    package main
 
    import "fmt"
    
    // empty interface
    type Empty interface{ }
    
    func print_value(value Empty){ 
        fmt.Println(value)
    }
    
    type person struct{
        name string
    }
    
    type account struct{
        id int
    }
    
    func main() {
        tom := person{"Tom"} 
        tom_acc := account{125} 
    
        print_value(tom) // {Tom} 
        print_value(tom_acc) // {125}
    }
    ```

    Здесь мы создаем две структуры с двумя полями. Интерфейс Empty не имеет ни одного метода. Метод print_value принимает пустой интерфейс Empty, который может содержать любое значение. Значение такого пустого интерфейса называется его динамическим или конкретным значением

- 

---

## Обработка ошибок

- Обработка ошибок с помощью возвращаемых значений на примере открытия несуществующего файла:

    ```go
    package main 
    import (
        "fmt"
        "os"
    )
    
    func main(){
    
        file, err := os.Open("./content.txt") 
        fmt.Println("file :", file) 
        fmt.Println("error:", err)
    }
    ```

    Если файл был успешно открыт, то переменная file будет содержать некоторый дескриптор открытого файла для операций с ним, а переменная err будет равна nil, то есть ошибка отсутствует. Но если файла не существует, или при его открытии возникли ошибки, то переменная file будет равна nil, а переменная err будет содержать информацию об ошибке.

    Если же файл прочитается без проблем, уже в переменную err будет возвращено значение nil

- Чтобы самостаятельно указывать описания ошиок, можно пользоваться следующей логикой: 

    ```go
    func factorial(n int) (int, interface{}){
        if(n < 0){
            return 0, "Недопустимое число. Должно быть больше 0"
        }   
        ...
    }
    ```

    Первое значение типа int представляет результат, а второе возвращаемое значение теоретически может представлять любой объект, поэтому в качестве его типа указан анонимный интерфейс interface{}, который соответствует произвольному объекту. Стоит отметить, что для ошибок в Go есть собственный тип, который можно использовать вместо анонимного интерфейса

- Для обработки ошибок язык Go предоставляет специальный интерфейс - error, который содержит один метод Error с возвращаемым типом string: 

    ```go
    type error interface{
        Error() string
    }
    ```

    Значение по умолчанию для типа error — nil. Любой тип, реализующий интерфейс error, может представлять тип ошибки. Например:

    ```go
    type param_error struct{}
    func (error_object param_error) Error() string{ 
        return "Invalid parameter"
    }
    
    func main(){
        obj := param_error{}
        fmt.Println(obj.Error())    // Invalid parameter
    
        fmt.Println(param_error{})   // Invalid parameter
    }
    ```

- В стандартной библиотеке языка Go имеется встроенный пакет errors, который реализует различные функции для управления ошибками. Он имеет функцию под названием New(), которая возвращает объекта интерфейса error и устанавливает его сообщение об ошибке:

    ```go
    package main 
    import (
        "fmt"
        "errors"
    )
    
    func factorial(n int) (int, error){
    
        if(n < 0){
            return 0, errors.New("недопустимое число: должно быть положительным")
        }
    ...
        return res, nil
    }

    func main(){
        fact, err := factorial(5)
        fmt.Println("Factorial:", fact)     // Factorial: 120
        fmt.Println("Error:", err)  // Error: <nil>
    
        fact, err = factorial(-5)
        fmt.Println("Factorial:", fact)     // Factorial: 0
        fmt.Println("Error:", err)  // Error: недопустимое число: должно быть положительным
    }
    ```

- Оператор defer позволяет выполнить определенную функцию в конце окружающей функции. Обычно с помощью оператора defer выполняется операции очистки, например, закрытие файлов, или какие-то действия, которые должны быть выполнены в самом конце.

- Оператор defer работает следующим образом:

    1. Оператор defer помещает вызов переданной ему функции в стек. Когда окружающая функция возвращает управление, вызываются все функции, хранящиеся в стеке. Функция, хранящаяся в конце стека, выполняется первой. Значения, переданные в аргументах функции defer, вычисляются, когда компилятор находит оператор defer

    2. В функциях defer могут выполняться как операции чтения, так и записи

    3. Возвращаемые значения могут быть изменены в функциях defer

    4. Оператор defer обеспечивает выполнение отложенных функций даже в случае ошибки или вызова функции panic, помогая очищать ресурсы

    ```go
    func main() {
        defer finish()
        fmt.Println("Program has been started")
        fmt.Println("Program is working")
    }
    
    func finish(){
        fmt.Println("Program has been finished")
    }
    ```


    При выполнении вышеописанного скрипта получим вывод: 

    ```
    Program has been started
    Program is working
    Program has been finished
    ```

- Если несколько функций вызываются с оператором defer, то те функции, которые вызываются раньше, будут выполняться позже всех.

- Оператор panic представляет еще один способ обработки ошибок. Он позволяет сгенерировать ошибку и выйти из программы. Он используется для проверки непредвиденных ошибок во всей программе и чем-то похож на исключения в других языках программирования. Всякий раз, когда в любой функции вызывается оператор panic, он останавливает выполнение этой функции и завершает выполнение программы. Но если в функции, где произошла ошибка, вызывваются функции с операторм defer, то перед завершением программы выполняются эти функции.

- В качестве параметра оператор panic принимает произвольное значение (формально интерфейс interface {}, которому в реальности соответствует произвольное значение):

    ```go
    panic (interface {})
    ```

    Пример применения: 

    ```go
    func main() {
        fmt.Println(divide(15, 5))
        fmt.Println(divide(4, 0))
        fmt.Println("Program has been finished")
    }
    func divide(x, y float64) float64{
        if y == 0{ 
            panic("Division by zero!")
        }
        return x / y
    }
    ```

    В функции main в вызове fmt.Println(divide(4, 0)) будет выполняться оператор panic, поскольку второй параметр функции divide равен 0. И в этом случае все последующие операции, которые идут после этого вызова, например, в данном случае это вызов fmt.Println("Program has been finished"), не будут выполняться. В этом случае мы получим следующий консольный вывод:

    ```
    panic: Division by zero!
    ```

- В некоторых случаях мы можем выполнить некоторую очистку или другую необходимую операцию, прежде чем программа завершится. Это можно сделать, используя функцию с оператором defer, которая выполняется перед завершением программы. Для этого перед вызовом методов, в которых присутствует оператор panic стоит вызвать методы с операторов defer

- Для обработки ошибок, сгенерированных функцией panic, Go предоставляет встроенную функцию recover(). Эта функция может служить некоторой аналогией для конструкций try-catch в других языках. Функция recover используется внутри функций defer (поскольку после вызова panic выполняются только операторы defer). Функция recover возвращает значение, переданное через panic. Если в программе не было вызовов panic, или recover() был вызван не в отложенной функции, то recover() возвращает nil. Например: 

    ```go
    package main
    import "fmt"
    
    func try_catch(){
    
        if r := recover(); r != nil { 
            fmt.Println("Error:", r) 
        }
    }
    
    func divide(x, y float64) float64{
        defer try_catch()
        if y == 0{ 
            panic("Division by zero!")
        }
        return x / y
    }
    
    func main() {
        fmt.Println(divide(4, 0))
        fmt.Println("Program has been finished")
    }
    ```

    Здесь демонстрируется механизм обработки ошибок, похожий на try-catch в других языках программирования, но реализованный с использованием встроенных функций Go: defer, panic и recover. Прежде всего для перехвата ошибки, которая сгенерирована оператором panic(), определена функция try_catch(). Вначале проверяем был ли вызов panic:
    
    ```go
    if r := recover(); r != nil { ... }
    ```

    Выражение r := recover() пытается перехватить вызов panic() и присваивает результат функции переменной r. Далее выражение if r != nil проверяет, был ли вызов panic(). Если r не равно nil, это означает, что был вызов panic() и он успешно перехвачен. В конце выводим сообщение об ошибке вместе со значением, переданным в panic (в данном случае "Division by zero!")

- panic останавливает нормальное выполнение программы и начинает раскручивать стек вызовов, выполняя все отложенные defer-функции. Важно отметить, что после перехвата паники с помощью recover() программа продолжит выполнение после точки, где была вызвана функция, содержащая defer и recover

---

## Сетевое программирование

- Основной функционал по работе с сетью представлен пакетом net. Этот пакет предоставляет различные низкоуровневые сетевые примитивы, через которые идет взамодействие по сети

- Для отправки запросов к ресурсам в сети применяется функция net.Dial():

    ```go
    func Dial(network, address string) (Conn, error)
    ```

    Эта функция принимает два параметра: network - тип протокола и address - адрес ресурса. Есть следующие типы протоколов:

    1. tcp, tcp4, tcp6: протокол TCP. tcp по умолчанию представляет tcp4, цифра в конце указывает, какой тип адресов будет использоваться: IPv4 или IPv6

    2. udp, udp4, udp6: протокол UDP. udp по умолчанию представляет udp4

    3. ip, ip4, ip6: протокол IP. ip по умолчанию представляет ip4

    4. unix, unixgram, unixpacket: сокеты Unix

    Функция возращает объект, который реализует интерфейс net.Conn. Этот интерфейс, в свою очередь, применяет интерфейсы  io.Reader и io.Writer, то есть может использоваться как поток для чтения и записи. Пакет net предоставляет базовые реализации этого интерфейса в виде типов IPConn, UDPConn, TCPConn. В зависимости от используемого протокола возвращается соответствующий тип. Таким образом, используя данную функцию, мы можем отправлять запросы по протоколу TCP и UDP. Например:

    ```go
    package main
    import (
        "fmt"
        "os"
        "net"
        "io"
    )
    func main() {
        httpRequest:="GET / HTTP/1.1\n" + 
            "Host: golang.org\n\n"
        conn, err := net.Dial("tcp", "golang.org:80") 
        if err != nil { 
            fmt.Println(err) 
            return
        } 
        defer conn.Close() 
    
        if _, err = conn.Write([]byte(httpRequest)); err != nil { 
            fmt.Println(err) 
            return
        }
    
        io.Copy(os.Stdout, conn) 
        fmt.Println("Done")
    }
    ```

    В данном случае мы фактически обращаемся к веб-ресурсу golang.ru. Так как net.Conn реализует интерфейсы io.Reader и io.Writer, то в данный объект можно записывать данные - фактически посылать по сети данные и можно считывать с него данные - получать данные из сети. Например, conn.Write([]byte(httpRequest)) посылает данные, которые здесь представлены переменной httpRequest. Так как метод Write отправляет срез байтов, то любые данные надо преобразовать в срез байтов



---

## Реляционные базы данных

Для работы с реляционными базами данных в языке Go применяется встроенный пакет database/sql. Однако он не используется сам по себе. Он лишь предоставляет универсальный интерфейс для работы с базами данных. Для работы с конкретной СУБД нам также необходим драйвер. Список доступных драйверов можно найти [здесь](https://go.dev/wiki/SQLDrivers). Однако поскольку драйвера реализуют одни и те же интерфейсы, то в принципе работа с различными СУБД будет идентична

- Для того, чтобы начать работу с базой данных, необходимо открыть подключение с помощью функции Open():

    ```go
    func Open(driverName, dataSourceName string) (*DB, error)
    ```

    Затем взаимодействие с базой данных осуществляется посредством методов объекта DB:

    ```go
    func (db *DB) Exec(query string, args ...interface{}) (Result, error)
    func (db *DB) Query(query string, args ...interface{}) (*Rows, error)
    func (db *DB) QueryRow(query string, args ...interface{}) *Row
    func (db *DB) Close() error 
    ```

    1. Метод Exec() выполняет некоторое sql-выражение, которое передается через первый параметр, не возвращая никакого результата. Метод также принимает дополнительные параметры, с помощью которых можно передать значения в выполняемое sql-выражение. Например, абстрактная операция добавления данных в БД, которая предполагает выполнение команды INSERT:

    ```go
    result, err := db.Exec("INSERT INTO Products (model, company, price) VALUES ('iPhone X', 'Apple', 72000);")
    ```

    2. Метод Query() для выполнения запроса, который возвращает какие-либо данные. Обычно это запросы, которые содержат команду SELECT:

    ```go
    rows, err := db.Query("SELECT name FROM users WHERE age=23;")
    ```

    Результатом запроса является объект *Rows - по сути набор строк. С помощью ряда его методов можно извлечь полученные данные:

    ```go
    func (rs *Rows) Columns() ([]string, error)     // возвращает названия столбцов набора
    func (rs *Rows) Next() bool                     // возвращает true если в наборе есть еще одна строка и переходит к ней
    func (rs *Rows) Scan(dest ...interface{}) error     // считывает данные строки в переменные
    func (rs *Rows) Close() error    
    ```

    Общий принцип чтения набора строк выглядит примерно следующим образом:

    ```go
    rows, err := db.Query("SELECT ...")
    ...
    defer rows.Close()
    for rows.Next() {
        var id int
        var name string
        rows.Scan(&id, &name)
        fmt.Println(id, name)
    }
    ```

    3. Метод QueryRow() возвращает одну строку в виде объекта *Row. Как правило, этот метод применяется для получение единичного объекта, например, по id. Этот объект имеет метод Scan(), который позволяет извлечь данные из строки:

    ```go
    func (r *Row) Scan(dest ...interface{}) error
    ```

- Для работы с PostgreSQL в Go мы можем применять различные драйверы, но в данном случае мы будем использовать Pure Go Postgres driver: 

    ```
    go get github.com/lib/pq
    ```

- Для открытия соединения с базой данных в функцию sql.Open() передается имя драйвера "postgres" и строка подключения:

    ```go
    connStr := "user=postgres password=mypass dbname=productdb sslmode=disable"
    db, err := sql.Open("postgres", connStr)
    ```

    В результате установки подлючения метод db.Open возвратить объект *DB, через который можно будет взаимодействовать в базой данных

- Ниже приведен скрипт-референс для вполнения метода Exec(): 

    ```go
    package main
    import (
        "database/sql"
        "fmt"
        _ "github.com/lib/pq"
    )
    
    func main() { 
    
        connStr := "user=postgres password=mypass dbname=productdb sslmode=disable"
        db, err := sql.Open("postgres", connStr)
        if err != nil {
            panic(err)
        } 
        defer db.Close()
        
        result, err := db.Exec("insert into Products (model, company, price) values ('iPhone X', $1, $2)", 
            "Apple", 72000)
        if err != nil{
            panic(err)
        }
        fmt.Println(result.LastInsertId())  // не поддерживается
        fmt.Println(result.RowsAffected())  // количество добавленных строк
    }
    ```

---

## Рефлексия

- Рефлексия предоставляет возможность исследовать данные во время выполнения программы. Используя рефлексию, мы можем проверить поведение любого метода, интерфейса, структуры или любых данных. Используя рефлексию, мы можем получить тип, поле и значение любого типа. Хотя в языке Go каждая переменная объявляется со своим типом, тем не менее, может быть много случаев, когда нам может понадобиться узнать тип переменной во время выполнения. Здесь вступает в дело рефлексия

- В языке Go в стандартной библиотеке за рефлексию отвечает встроенный пакет reflect. Этот пакет содержит несколько переменных и методов для манипулирования объектами различных типов и в основном используется для получения типа, значения и вида. Пакет reflect следует использовать для общего программирования или фреймворков, но избегать его в коде, для которого критически важна производительности, или там, где безопасность типов имеет важное значение. Рефлексия вносит издержки производительности, снижает безопасность типов и затрудняет поддержку кода

- Пакет reflect предоставляет функцию TypeOf() для получения типа переменной:

    ```go
    func TypeOf( i interface{}) type
    ```

- Функция reflect.ValueOf() вычисляет значение переменной:

    ```go
    value := reflect.ValueOf(variable)
    ```

- Функция NumField используется для получения количества полей, содержащихся в структуре. Поскольку эта функция определена в пакете reflect, она работает только с типом reflect.Value или reflect: 

    ```go
    package main 
 
    import (
        "fmt"
        "reflect"
    )
    
    type person struct{
    
        name string
        age int
    }
    
    func main(){
    
        user := person{"Tom", 41}    
        user_value := reflect.ValueOf(user) 
        num_fields := user_value.NumField()
    
        fmt.Println("Fields number:", num_fields)  // Fields number: 2
    }
    ```

- Функция Field используется для получения значения полей структуры. Она возвращает значение типа reflect.Value:

    ```go
    package main 
 
    import (
        "fmt"
        "reflect"
    )
    
    type person struct{
    
        name string
        age int
    }
    
    func main(){
    
        user := person{"Tom", 41} 
    
        user_value := reflect.ValueOf(user) 
    
        num_fields := user_value.NumField()
    
        for i:=0; i < num_fields; i++{
    
            fmt.Printf("Field %d. Value: %v  Type: %T\n", i+1, user_value.Field(i), user_value.Field(i))
        }
    }
    ```

    ```
    Field 1. Value: Tom  Type: reflect.Value
    Field 2. Value: 41  Type: reflect.Value
    ```

- Функция reflect.Kind() позволяет определить исходный тип значения reflect.Value. Например, выше мы получали тип полей как reflect.Value. Теперь получим исходный тип:

    ```go
    package main 
 
    import (
        "fmt"
        "reflect"
    )
    
    type person struct{
    
        name string
        age int
    }
    
    func main(){
    
        user := person{"Tom", 41} 
    
        user_value := reflect.ValueOf(user) 
        fmt.Printf("User_Value: %v  Type: %v\n", user_value, user_value.Kind())
    
        // получаем количество полей
        num_fields := user_value.NumField()
        // исследуем все поля
        for i:=0; i < num_fields; i++{
    
            fmt.Printf("Field %d. Value: %v  Type: %v\n", i+1, user_value.Field(i), user_value.Field(i).Kind())
        }
    }
    ```

    ```
    User_Value: {Tom 41}  Type: struct
    Field 1. Value: Tom  Type: string
    Field 2. Value: 41  Type: int
    ```

---

## Терминал

- Если посмотреть на вывод **go help**, можно увидеть не очень малое множество допустимых команд (у каждой еще свои подкоманды), но основные вот: 

    1. `go run`. Компиляция и запуск go-скриптов
    2. `go build`. Компиляция go-скриптов в исполняемый файл без последующего запуска скомпилированного файла
    3. `go install`. Установка пакетов в **$GOBIN**
    4. `go test`. Запуск тестов в указанном пакете. Используеся для модульного тестирования
    5. `go mod`. Управление зависимостями (**init**, **tidy**)
    6. `go fmt`. Автоматическое форматирование кода
    7. `go vet`. Проверка кода на типичные ошибки
    8. `go doc`. Показывает документацию к пакету
    9. `go list`. Выводит список зависимостей в проекте

---

## Корутины

--- 

## Каналы

---

## Дженерики

---

## Стиль

- Стиль в гошке весьма интересный. Например, не стоит повторять в названиях методов наименования пакетов, а также для методов не стоит повторять наименования аргументов, принимаемых методом, в его названии. Честно, не понимаю, почему - при использовании имен аргументов в имени метода становится лучше понятно, с чем мы взаимодействуем, но здесь это харам. Т.е. является харамом что-то вроде: 

    ```go
    package yamlconfig

    func ParseYAMLConfig(input string) (*Config, error)

    func (c *Config) WriteConfigTo(w io.Writer) (int64, error)

    func OverrideFirstWithSecond(dest, source *Config) error
    ```

    Но при этом в случае наличия метода со схожим названием при инициализации нового метода допускается указание дополнительной информации, которую лучше не включать в исходное название в соответствии с описанным выше: 

    ```go
    func (c *Config) WriteTextTo(w io.Writer) (int64, error)
    func (c *Config) WriteBinaryTo(w io.Writer) (int64, error)
    ```

    - Также не стоит добавлять фразы, описывающее получение информации. `Get`, например. Для метода который возвращает, допустим, наименование работы, лучше использовать название `JobName`, а не **Get**JobName
    - А для методов, которые что-то делают (записывают, например), будет правильным использовать глаголы в их названии - `WriteDetail`
    - Если разница метода только в байтах принимаемого значения (int32, int64), стоит указывать это в названии (ParseInt32 - ParseInt64)

# Советы по написанию поддерживаемых программ

## Идентификаторы

- Идентификаторы - синонимы имен. В принципе, если не смотреть на 'правильный стиль' с точки зрения самого кода, а смотреть на 'правильный стиль' с точки зрения человека, который будет его читать и поддерживать, здесь очень много аналогий с тем же питоном. Т.е. в ход идет этика разработчика, а не этика языка
- Имена переменным лучше давать исходя из их ясности, а не краткости, о которой я писал выше. Хорошее имя лаконично, оно является спасательным (имя метода должно описывать применение переменной, а не ее содержимое. Хорошее имя описывает результат функции или поведение метода, а не его реализацию. назначение пакета, а не его содержимое). Хорошее имя предсказуемо. Также важно упомянуть, что Go вляется языков со строгой типизацией, ввиду чего просто не позволит передать, например в параметр метода с типом **map** объект скалярного типа, ввиду чего суффиксы с наименованием обрабатываемого типа данных просто излишни:
    ```go
    var usersMap map[string]*User  // суффикс 'Map' излишен
    ```
- Интересная практика, о которой я прочитал - давать переменным/методам тем большее имя, чем дальше от момента инициализации переменной/метода она/он будет использован(-а). Т.е. если метод используется единожд сразу после инициализации, нет смысла делать его имя длинным, а если метод используется на протяжении длинного участка кода, стоит обозвать его более длинным именем и привнести больше контекста в это имя:

    ```go
    type Person struct {
        Name string
        Age  int
    }

    // AverageAge returns the average age of people.
    func AverageAge(people []Person) int {
        if len(people) == 0 {
            return 0
        }

        var count, sum int
        for _, p := range people {
            sum += p.Age
            count += 1
        }

        return sum / count
    }
    ```

    Грубо говоря, длина имени должна показывать важность переменной. Это логично, но раньше этот принцип я использовал на подсознательном уровне

- В Go принято соглашение, что интересно, о максимальном сокращении имен объектов. Зачастую, если рассматривать аргументы методов, например, аргумент является сокращением от его типа (структура Person -> аргумент p)

- Также рекомендуется использовать единый стиль деклораций (объявление и инициализация). Мне больше всего понравился вариант `var x int = 5`. Т.е. `var x int` преобладает над `var x = 0`. Остановлюсь на нем. Также, если требуется задать нулевое значение определенного типа, переменная просто объявляется, без инициализации (тоже использовать). Если 2 переменные близко связаны между собой, стоит проводить их декларацию в одной строке: 

    ```go
    var min, max := 0, 1000
    ```

- Если есть разногласия по стилю, их стоит выносить на обсуждения только в том случае, если код не проходит через `go fmt`

---

## Комментарии

- Важно понимать, что комментарий должен делать одну и только одну вещь из 3-х приведенных: 
    1. Объяснить, что делает код
    2. Объяснить, как код что-то делает
    3. Объяснить, зачем код что-то делает

- Комментарии в переменных и константах должны описывать их содержимое, а не предназначение: 
    ```go
    // sizeCalculationDisabled указывает, безопасно ли
    // рассчитать ширину и выравнивание типов. См. dowidth.
    var sizeCalculationDisabled bool
    ```

- Иногда лучшее имя для переменной скрывается в комментарии. В примере приведено имя `register` - понятно, что регистр, но регистр чего? если добавить уточнение, что он связан с sql, например `sqlDrivers`, то станет лучше: 
    ```go
    // реестр драйверов SQL
    var registry = make(map[string]*sql.Driver)
    ```

- При разработке своих пакетов лучше всего комментировать все, что не является кратким и явным одновременно. При этом любая функция должна быть прокомментирована вне зависимости от ее краткости и сложности. Однако есть исключение - не стоит документировать методы, реализующие интерфейс: 
    ```go
    // Read реализует интерфейс io.Reader
    func (r *FileReader) Read(buf []byte) (int, error)
    ```

    Приведенный комментарий приосит больше ущерба, чем пользы - в нем нет никакой информации кроме той, что и так ясна из строки кода

- Если стало понятно, что код перед глазами попахивает, лучше всего его переписать, чем насыщать его комментариями. Если столкнусь с подобным комментарием, лучше завести тикет с напоминанием о рефакторинге. Также буде правильным решением в тикете указать ник человека, который либо заметил проблему, либо к которому лучше обратиться за решением проблемы

---

## Структура пакета

- Важная особенность Go по сравнению с другими языками (java, c++) - в нем нет столь большого модификатора доступов. В Go всего 2 модификатора доступа: общедоступный и правтный идентификаторы, что обозначается первой буквой идентификатора (заглавная/строчня). Если модификатор общедоступный, его имя начинается с большой буквы, и на него может ссылаться любой другой пакет в Go

- Лучше предпочесть меньшее кол-во пакетов большего размера, чем наоборот. Но при этом стоит помнить, что каждый пакет должен выполнять строго одну функцию (парсинг .xml или журналирование), иначе велик шанс повторить судьбу пакета common. Также в каждом пакете, кроме `cmd/` и `internal/` должен находиться исходный код

- Рекомендации при создании пакетов: 
    1. Начинать каждый пакет с одного .go файла. Лучше всего присвоить ему то же имя, что и у каталога (для каталога **https** первым файлом лучше всего сделать **https.go**)
    2. При росте пакета можно разделить различные функции на несколько файлов. Например, файл **messages.go** будет содержать типы Request и REsponse, файл client.go - тип Client, файл server.go - тип сервера
    3. Если у файлов оказались похожие декларации импорта, стоит подумать об их объединении. Как вариант, можно проанализировать наборы импорта и переместить их
    4. Разные файлы должны отвечать за разные области пакета. Не стоит разделять логику по работе с одним направлением на несколько файлов

- Касательно тестов - стоит предпочитать внутренние тесты внешним. Пример 'внутреннего теста' в разговорной речи - под файл **http.go** можно написать файл **http_test.go** и использовать декларацию пакета **http**. Данное действие скомпилирует код **http_test.go**, как будто он часть пакета **http**. Опять же, подобный тест называется **внутренним** в разговорной речи

- Инструмент **go** также поддерживает специальное объявление пакета, заканчивающее суффиксом `test`, что позволяет тестовым файлам жить в одном пакете с кодом, но когда такие тесты компилируются, они не является часть кода пакета, в котором находятся, а живут в своем собственном пакете, что позволяет писать тесты так, словно другой пакет вызывает тестовый код. Подобные тесты называются **внешними** 

- Оптимальнее всего использовать внутренние тесты, поскольку они позволят целенаправленно тестировать каждый метод/функцию, избегая лишней бюррократии внешнего тестирования. НО обязательно нужно поместить во внешний тестовый файл примеры тестовых функций (`Example`), что гарантирует, что при просмотреть в **godoc** примеры получат соответствующий префикс пакета и могут быть легко скомпилированы

---

## Структура проекта

---

## Структура API

---

## Обработка ошибок

---

## Параллелизм

---

остановился на пункте 5.1.3