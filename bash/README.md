# Теория по bash

- Здесь будет собрана теория в текстовом виде ради увеличения скорости ее запоминания и возможность подглядеть при необходимости

## Введение в bash-скрипты

- Bash-скрипт или shell-скрипт представляет текстовый файл, который содержит последовательность команд. По сути, все, что может запускать несколько команд, можно считать shell-скриптом. Ритуальный скрипт приветствования мира: 

    ```bash
    #!/bin/bash

    echo "Hello, World!"
    exit 0
    ```
    
- В первой строке скрипта стоит `shebang`: **#!/bin/bash**. Этот элемент сценария сообщает оболочке, в которой будет выполняться этот скрипт, какую подоболочку следует выполнить для запуска этого сценария. shebang всегда начинается с `#!`. А далее следует имя подоболочки, которая должна выполнить скрипт. Так, в примере выше в качестве подоболочки применяется `/bin/bash`, но в реальности это может быть любая другая оболочка. В принципе скрипт может не включать в себя *shebang*, и во многих случаях такой скрипт равно будет работать. Однако если пользователь попытается в ней запустить скрипт без shebang в оболочке, отличной от */bin/bash*, то он скорее всего потерпит неудачу. Поэтому лучше всегда добавлять *shebang*

- Комментарии в bash начинаются с решетки: **# paste something here**

- Использование команды **exit 0** является хорошей практикой. Если же числовой код равен не 0, а какому-то другому числу, это будет означать, что возникла проблема. В более сложных сценариях можно использовать разные числовые коды, чтобы указать, что определенное условие не выполнено

- Существует несколько вариантов запустить shell-скрипт: 

    1. Сделать скрипт исполняемым и запустить как обычную программу
    2. Запустить скрипт как аргумент программы bash
    3. Сделать скрипт исполняемым и запустить как обычную программу

    Первый вариант - можно сделать скрипт исполняемым, если добавить ему права при помощи команды: 

    ```bash
    chmod +x script_name
    ```

    Третий вариант - включение скрипта в текущую оболочку. Это может быть полезно, если скрипт содержит переменные, которые надо сделать активными в текущей оболочке. Существует два способа подобного вызова скрипта:

    ```bash
    . script_name
    source script_name
    ```
    
    Стоит учитывать, что если скрипт использует команду *exit* для завершения, то она закрывает текущую оболочку

---

## Переменные и получение ввода

- Для определения переменных применяется следующий синтаксис:

    ```bash
    var_name=var_value
    ```
    
- Для обращения к переменной используется ее имя, перед которым ставится символ `$`. Например, вывод значения переменной с помощью команды *echo*:

    ```bash
    echo $message
    ```

- Стоит отметить, что система при загрузке уже устанавливает ряд глобальных переменных - переменных окружения. Эти переменные можно получить с помощью команды env. Как я понимаю, терминал представляет из себя именно что realtime-shell (только сейчас дошел до этой идеи)

- При определении переменных следует помнить, что переменная определяется только для текущей оболочки. Это означает, что при запуске подоболочки из текущей оболочки, переменной там не будет. А если определить переменную в подоболочке, то эта переменная не будет доступна для родительской оболочки - как только произойдет выход из подоболочки и возвращение в родительскую оболочку, переменной там уже не будет:

    ```bash
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ cringe_var=cringe
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ echo $cringe_var
    cringe
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ 
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ ./echo_cringe 
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ 
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ 
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ echo $cringe_var
    cringe
    ```

- Чтобы сделать переменную родительской оболочки доступной для всех дочерних подоболочек, такая переменная должна быть определена с помощью команды export:

    ```bash
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ ./echo_cringe 

    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ export cringe_var=cringe
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ ./echo_cringe 
    cringe
    ```

    Если надо сделать, чтобы переменные были доступны глобально, всегда даже после перезагрузки машины, то их следует добавить в переменные среды.

- Расспространенной техникой при работе с переменными является их встраивание (`sourcing`) в текущую оболочку. В этом случае переменные часто определяются в одном файле. Например, определеим в домашнем каталоге файл *sourcing_vars* со следующим содержимым:

    ```bash
    #!/bin/bash

    NICKNAME="quing"
    AGE=20
    TOWN="Moscow"
    ```

    Здесь определены три переменных. Встроим файл в консоль и обратимся к переменны: 

    ```bash
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ . sourcing_vars 
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ echo $TOWN
    Moscow
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ echo $NICKNAME
    quing
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ echo $AGE
    20
    ```
    
    Первая команда - `. sourcing_vars` собственно представляет встраивание содержимого файла в консоль, после чего мы сможем обращаться к переменным. Встраивание переменных используется для выполнения скрипта в текущем окружении оболочки, а не в новой подсессии. Разница с простым выполнением скрипта заключается в создании последним новой подоболочки, внутри которой происходит само выполнение команд

- С помощью команды `read` можно получить из терминала некоторые данные в некоторую переменную. Например: 

    ```bash
    #!/bin/bash

    echo "Enter your nickname:"
    read USER_NAME
    echo "Your name: $USER_NAME"

    exit 0

---

## Аргументы скрипта

- При запуске скрипта ему можно передать некоторые аргументы из командной строки. Внутри скрипта эти аргументы доступны через номера аргументов. Например, первый аргмуент доступен через $1, второй аргумент через - $2 и так далее. Также есть специальный идентификатор - $0, который всегда хранит имя скрипта. Простой пример использования аргументов: 

    ```bash
    #!/bin/bash

    echo $0 $1
    exit 0
    ```

Кроме $0 внутри скрипта можно использовать еще ряд специальных идентификаторов:    
    
    1. \$#: число аргументов
    2. \$@ и \$*: строка с аргументами

    Простой скрипт для проверки:

    ```bash
    #!/bin/bash

    echo "Total arguments incoming: $#"
    echo "String with arguments (@) $@ ; (*) $*"

    exit 0
    ```

    Вывод: 

    ```bash
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ bash check_arguments_amount cringe file top
    Total arguments incoming: 3
    String with arguments (@) cringe file top ; (*) cringe file top
    ```
