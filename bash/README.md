# Теория по bash

- Здесь будет собрана теория в текстовом виде ради увеличения скорости ее запоминания и возможность подглядеть при необходимости

## Введение в bash-скрипты

- Bash-скрипт или shell-скрипт представляет текстовый файл, который содержит последовательность команд. По сути, все, что может запускать несколько команд, можно считать shell-скриптом. Ритуальный скрипт приветствования мира: 

    ```bash
    #!/bin/bash

    echo "Hello, World!"
    exit 0
    ```
    
- В первой строке скрипта стоит `shebang`: **#!/bin/bash**. Этот элемент сценария сообщает оболочке, в которой будет выполняться этот скрипт, какую подоболочку следует выполнить для запуска этого сценария. shebang всегда начинается с `#!`. А далее следует имя подоболочки, которая должна выполнить скрипт. Так, в примере выше в качестве подоболочки применяется `/bin/bash`, но в реальности это может быть любая другая оболочка. В принципе скрипт может не включать в себя *shebang*, и во многих случаях такой скрипт равно будет работать. Однако если пользователь попытается в ней запустить скрипт без shebang в оболочке, отличной от */bin/bash*, то он скорее всего потерпит неудачу. Поэтому лучше всегда добавлять *shebang*

- Комментарии в bash начинаются с решетки: **# paste something here**

- Использование команды **exit 0** является хорошей практикой. Если же числовой код равен не 0, а какому-то другому числу, это будет означать, что возникла проблема. В более сложных сценариях можно использовать разные числовые коды, чтобы указать, что определенное условие не выполнено

- Существует несколько вариантов запустить shell-скрипт: 

    1. Сделать скрипт исполняемым и запустить как обычную программу

    2. Запустить скрипт как аргумент программы bash

    3. Сделать скрипт исполняемым и запустить как обычную программу

    Первый вариант - можно сделать скрипт исполняемым, если добавить ему права при помощи команды: 

    ```bash
    chmod +x script_name
    ```

    Третий вариант - включение скрипта в текущую оболочку. Это может быть полезно, если скрипт содержит переменные, которые надо сделать активными в текущей оболочке. Существует два способа подобного вызова скрипта:

    ```bash
    . script_name
    source script_name
    ```
    
    Стоит учитывать, что если скрипт использует команду *exit* для завершения, то она закрывает текущую оболочку

---

## Переменные и получение ввода

- Для определения переменных применяется следующий синтаксис:

    ```bash
    var_name=var_value
    ```

Стоит уточнить, что вариант `var_name = var_value` не прокатит - вылетит ошибка. Для записи значения в переменную необходимо пользоваться ровно тем синтаксисом, который представлен выше
    
- Для обращения к переменной используется ее имя, перед которым ставится символ `$`. Например, вывод значения переменной с помощью команды *echo*:

    ```bash
    echo $message
    ```

- Стоит отметить, что система при загрузке уже устанавливает ряд глобальных переменных - переменных окружения. Эти переменные можно получить с помощью команды env. Как я понимаю, терминал представляет из себя именно что realtime-shell (только сейчас дошел до этой идеи)

- При определении переменных следует помнить, что переменная определяется только для текущей оболочки. Это означает, что при запуске подоболочки из текущей оболочки, переменной там не будет. А если определить переменную в подоболочке, то эта переменная не будет доступна для родительской оболочки - как только произойдет выход из подоболочки и возвращение в родительскую оболочку, переменной там уже не будет:

    ```bash
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ cringe_var=cringe
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ echo $cringe_var
    cringe
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ 
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ ./echo_cringe 
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ 
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ 
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ echo $cringe_var
    cringe
    ```

- Чтобы сделать переменную родительской оболочки доступной для всех дочерних подоболочек, такая переменная должна быть определена с помощью команды export:

    ```bash
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ ./echo_cringe 

    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ export cringe_var=cringe
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ ./echo_cringe 
    cringe
    ```

    Если надо сделать, чтобы переменные были доступны глобально, всегда даже после перезагрузки машины, то их следует добавить в переменные среды.

- Расспространенной техникой при работе с переменными является их встраивание (`sourcing`) в текущую оболочку. В этом случае переменные часто определяются в одном файле. Например, определеим в домашнем каталоге файл *sourcing_vars* со следующим содержимым:

    ```bash
    #!/bin/bash

    NICKNAME="quing"
    AGE=20
    TOWN="Moscow"
    ```

    Здесь определены три переменных. Встроим файл в консоль и обратимся к переменны: 

    ```bash
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ . sourcing_vars 
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ echo $TOWN
    Moscow
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ echo $NICKNAME
    quing
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ echo $AGE
    20
    ```
    
    Первая команда - `. sourcing_vars` собственно представляет встраивание содержимого файла в консоль, после чего мы сможем обращаться к переменным. Встраивание переменных используется для выполнения скрипта в текущем окружении оболочки, а не в новой подсессии. Разница с простым выполнением скрипта заключается в создании последним новой подоболочки, внутри которой происходит само выполнение команд

- С помощью команды `read` можно получить из терминала некоторые данные в некоторую переменную. Например: 

    ```bash
    #!/bin/bash

    echo "Enter your nickname:"
    read USER_NAME
    echo "Your name: $USER_NAME"

    exit 0
    ```

---

## Аргументы скрипта

- При запуске скрипта ему можно передать некоторые аргументы из командной строки. Внутри скрипта эти аргументы доступны через номера аргументов. Например, первый аргмуент доступен через $1, второй аргумент через - $2 и так далее. Также есть специальный идентификатор - $0, который всегда хранит имя скрипта. Простой пример использования аргументов: 

    ```bash
    #!/bin/bash

    echo $0 $1
    exit 
    ```

Кроме $0 внутри скрипта можно использовать еще ряд специальных идентификаторов:    
    
    1. \$#: число аргументов
    2. \$@ и \$*: строка с аргументами

    Простой скрипт для проверки:

    ```bash
    #!/bin/bash

    echo "Total arguments incoming: $#"
    echo "String with arguments (@) $@ ; (*) $*"

    exit 0
    ```

    Вывод: 

    ```bash
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_files$ bash check_arguments_amount cringe file top
    Total arguments incoming: 3
    String with arguments (@) cringe file top ; (*) cringe file top
    ```

---

## Результаты команд и операторов

- `command substitution` - возможность представить результат выполнения одной команды в качестве аргумента другой команды. Для этого команда помещается в косые кавычки. Например, выведем текущую дату в формате "dd.MM.yy":

    ```bash
    #!/bin/bash

    echo "Today is `date +%d-%m-%y`"
    exit 0
    ```

    Вывод: 

    ```bash
    (base) quing@quing-st:~/github_projects/learning_mlops/bash/bash_scripts$ ./show_date 
    Today is 05-08-25
    ```

- Перед выполнением некоторых действий может потребоваться проверить, действительно ли переменной присвоено некоторое значение. Для этого Bash предлагает операторы подстановки или `substitution operators`. Например, используя операторы подстановки, можно присвоить значение по умолчанию, если переменной в данный момент присвоено значение. Мы можем использовать следующие операторы подстановки:

    1. *${parameter:-value}*: показывает значение value, если параметр не определен.

    2. *${parameter=value}*: присваивает значение value параметру, если параметр вообще не существует. Этот оператор ничего не делает, если параметр существует, но не имеет значения.

    3. *${parameter:=value}*: присваивает значение value параметру, если этот параметр в данный момент не имеет значения или вообще не существует.

    4. *${parameter:?value}*: показывает значение value, если параметр не существует или пуст. Использование этой конструкции приведет к немедленному прерыванию сценария оболочки.

    5. *${parameter:+value}*: показывает значение value, если параметр имеет значение. Если у параметра нет значения, ничего не происходит.

    Рассмотрим все варианты операторов подстановки на примере простого скрипта: 

    ```bash
    #!/bin/bash

    echo "Printing empty variable VAR: $VAR"
    echo

    echo "Show 'EmptyVar' if VAR is empty: ${VAR: -EmptyVar}"
    echo "Set 'SomeVal' if VAR is undefined: ${VAR=SomeVal}"
    echo

    echo "Printing variable VAR if it defined. Else give new value: ${VAR:=null}"
    VAR=
    echo "Printing variable VAR if it defined. Else give new value: ${VAR:=null}"
    echo

    echo "Show notification if VAR is undefined: ${VAR:? Variable VAR is undefined}"
    echo "Show notification if VOID is undefined: ${VOID:? Variable VAR is undefined}"
    echo

    exit 0
    ```

---

## Математические операции

- bash поддерживает простейшие математические операции: умножение, сложение, вычитание и деление, а также получение остатка от деления. При этом все операции имеют следующий синтаксис:

    ```bash
    $((operand1 operation operand2))
    ```

    Пример простой программы по сложению чисел: 

    ```bash
    #!/bin/bash

    echo "Enter 2 numbers: "
    read N1
    read N2

    result=$((N1 + N2))
    echo "Sum of N1 and N2 = $result"

    exit
    ```

- Есть также и другой способ определения математических операций - с помощью команды expr:

    ```bash
    #!/bin/bash

    echo "Enter 2 numbers: "
    read N1
    read N2

    result=`expr $N1 + $N2`
    echo "Sum of N1 and N2 = $result"

    exit
    ```

    Но этот вариант слишком дрочный по синтаксису, и у него есть нюанс: если использовать его для умножения чисел, перед знаком умножения требуется ставить символ `\`, поскольку символ умножения изначально предоставляет функционал подстановки файлов (разворачивание списка файлов, например)

--- 

## Условия и команда test

- Команда test проверяет соответствие некоторому условию. Она принимает следующие формы:

    ```bash
    test -e $1: проверяет, является ли $1 файлом.

    test -f $1: проверяет, является ли $1 обычным файлом, а не файлом устройства, каталогом или исполняемым файлом.

    test -d $1: проверяет, является ли $1 каталогом.

    test -x $1: проверяет, является ли $1 исполняемым файлом. Обратите внимание, что вы также можете проверить другие разрешения. Например, -g проверит, установлено ли разрешение SGID.

    test $1 -nt $2: проверяет, является ли $1 новее, чем $2.

    test $1 -ot $2: проверяет, старше ли $1, чем $2.

    test $1 -eq $2: проверяет, равны ли числа $1 и $2.

    test $1 -ne $2: проверяет, не равны ли числа $1 и $2.

    test $1 -gt $2: проверяет, является ли число $1 больше числа $2.

    test S1 -lt $2: проверяет, является ли число $1 меньше числа $2.

    test $1 -ge $2: проверяет, является ли число $1 большим или равным числу $2.

    test $1 -le $2: проверяет, является ли число $1 меньшим или равным числу $2.

    test -z $1: проверяет, определена ли переменная $1

    test $1: проверяет, определена ли переменная $1.

    test $1=$2: проверяет, совпадают ли строки $1 и $2. Применяется для сравнения значений двух переменных.

    test $1 != $2: проверяет, не равны ли строки $1 и $2. Также можно использовать ! со всеми другими командами test, а также для проверки отрицания утверждения.
    ```

    Также для проверки условий можно использовать сокращенную форму, при которой вся команда помещается в квадратные скобки, а слово "test" опускается. Например, вместо `test -f $1` пишется `[ -f $1 ]` (!! обратить внимание на пробелы после открывающей и перед закрывающей скобками)

- С помощью специальных операторов && и || можно объединять несколько условий в одно и составлять более сложные, комплексные условия. Они имеют следующий формат:

    ```bash
    команда1 && команда2
    команда1 || команда2
    ```

    Если используется `&&`, то вторая команда выполняется только в том случае, если первая команда выполнена успешно. Если используется `||`, то вторая команда выполняется только в том случае, если первую команду не удалось выполнить. Причем операнды этих операций представляют команды (любые). Однако нередко в качестве такого выступает условие команды `test`. Например, с помощью следующего условия можно узнать, является ли *$path* файлом, и вывести сообщение:

    ```bash
    #!/bin/bash

    echo "Enter a path to a file: "
    read PATH
    [ -f $PATH ] && echo $PATH is a file

    exit
    ```

    Получится такой вывод: 

    ```
    (base) quing@quing-st:~/github_projects/learning_mlops/bash$ ./bash_scripts/check_if_value_is_path 
    Enter a path to a file: 
    /home/quing/Desktop/m.py
    /home/quing/Desktop/m.py is a file
    ```

---

## Условная конструкция if..then..else
