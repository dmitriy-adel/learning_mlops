# Теория по Docker и Kubernetes

- Здесь будет собрана теория в текстовом виде ради увеличения скорости ее запоминания и возможность подглядеть при необходимости. Посколкьу в этот раз у меня нет референса в качестве уроков, я постараюсь реализовать свою идею по организации информации

## Термины

---

## Команды

- `docker run` - команда для запуска контейнера из образа. напрмиер,

    ```
    sudo docker run nginx
    ```

    запустит экземпляр приложения *nginx* на хосте, если образ есть локально. если образа нет на хосте, докер пойдет на *docker hub* и спулит его. например, bash-скрипт
    
    ```bash
    #!/bin/bash

    sudo docker run misaogura/whalesay "Whalesay for ur name! $1"

    exit
    ``` 
    
    запустит экземпляр контейнера *whalesay* из репозитория *misaogura* с именем, равным первому переданному аргументу
    
    чтобы запустить контейнер с определенной версией приложения, необходимо использовать тэги. например, 
    
    ```bash
    #!/bin/bash

    sudo docker run -it nginx:1.29
    
    exit
    ```
    запустит контейнер с *nginx* версии *1.29*, если такая есть (1.29 - тэг). флаги *-it* (t - терминал, i - интерактив) позволяют запускать контейнеры в интерактивном режиме и связывать свой терминал с терминалом контейнера

- `docker ps` - команда покажет запущенные контейнеры
    - чтобы увидеть все спуленные контейнеры, надо использовать флаг **-a**
    - флаг **-q** переключает вывод в 'тихий' режим, который показывает только id контейнеров
    - флаг **-f** предоставляет возможности фильтра. фильтровать вывод можно по метаданным контейнера (о них более подробно рассказано в docker inspect)

- `docker stop` - команда, используемая для остановки контейнера по его *CONTAINER ID*. для остановки всех доступных контейнеров стоит использовать скрипт: 

    ```bash
    #!/bin/bash

    sudo docker stop $(sudo docker ps -q)
    exit
    ```

- `docker rm` - удаление остановленного или заврешнного контейнера по имени или id. ниже приведен пример использования *docker rm* для удалениях всех остановленных контейнеров, кроме последних 3-х, отсортированных по времени создания

    ```bash
    #!/bin/bash

    sduo docker rm $(docker ps -a -q -f status=exited | tail -n +4)

    exit
    ```

- `docker images` - покажет все образы, установленные локально. каждый контейнер привязан к собственному образу, поэтому нельзя удалить образ, не удалив все контейнеры от него

- `docker rmi` - команда для удаления образов по имени или по id. образ можно удалить только в том случае, если на него больше не ссылаются контейнеры 

- `docker pull` - команда для скачивания образов с хаба. чтобы спулить определенную версию, надо использовать тэги (:(tag)vers.ion)

- `docker inspect` - вывод полной информации по контейнеру 

- `docker logs` - просмотр логов контейнера. что интересно, если стопнуть контейнер, и после этого запросить его логи, логи все равно будут выведены

---

## Идеи

- Контейнер - изолированное приложение со своими процессами, своей сетью и своим монтированием. docker контейнеры очень похожи на виртуальные машины за тем исключением, что в docker контейнерах одинаковая операционная система, в то время как на виртуалках - нет. контейнеры берут OS хоста и строятся вокруг нее, и есть пара нюансов: 

    1. Linux
        - Контейнеры используют Linux-ядро. Поэтому Linux-контейнеры можно запустить только на Linux (нельзя просто так взять и запустить их напрямую на Windows или macOS)

    2. Windows
        - Есть два типа контейнеров: 
            - Windows containers — используют Windows-ядро (могут запускать только Windows-приложения).

            - Linux containers — для их запуска Docker Desktop поднимает тонкую виртуалку (обычно на WSL2 или Hyper-V) с Linux-ядром. И уже там крутятся Linux-контейнеры.

    Т.е. получается, что да, на «голом» Windows нельзя запустить Linux-контейнеры. Но в реальности Docker Desktop решает это за счёт WSL2

- Основные отличия контейнеров и vm:

    - Ресурсы: ВМ потребляют больше памяти и дискового пространства, так как каждая из них содержит целую ОС. Контейнеры легче и компактнее.

    - Скорость: Контейнеры запускаются быстрее, чем ВМ.

    - Изоляция: ВМ изолированы жёстко (у каждой своё ядро), у контейнеров изоляция мягче, так как они делят ядро хоста.

    - Жизненный цикл: Контейнер существует, пока работает процесс внутри него. Если процесс завершается, контейнер тоже останавливается.

    - ОС внутри: В контейнер нельзя «поставить» произвольную ОС с собственным ядром. Контейнеры используют ядро хоста. Поэтому Linux-контейнеры работают только с Linux-ядром. На Windows и macOS они запускаются через виртуализацию (например, WSL2).

    Контейнеры легче и быстрее виртуальных машин, поскольку виртуальная машина эмулирует всё «железо» и запускает поверх него собственную ОС со своим ядром, а контейнер использует общее ядро хоста, но имеет собственное окружение для приложений

- вывод логов остановленного контейнера. я запустил одним из вышеупомянутых скриптов контейнер, скопировал его id, остановил запущенный контейнер, и попробовал взять у него логи - логи я увидел. и увидел, потому что: 

    1. Когда контейнер работает, его stdout и stderr перенаправляются в специальный лог-драйвер Docker (по умолчанию — json-file)

    2. Этот драйвер пишет логи в файлы на хосте (обычно в /var/lib/docker/containers/<container_id>/<container_id>-json.log)

    3. Когда контейнер останавливается, Docker не удаляет эти файлы — они остаются доступны для docker logs

    4. Логи контейнера исчезнут только в том случае, если его удалить при помощи команды docker rm

---
